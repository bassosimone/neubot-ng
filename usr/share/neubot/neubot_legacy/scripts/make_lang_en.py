#!/usr/bin/env python

#
# Copyright (c) 2011 Simone Basso <bassosimone@gmail.com>,
#  NEXA Center for Internet & Society at Politecnico di Torino
#
# This file is part of Neubot <http://www.neubot.org/>.
#
# Neubot is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Neubot is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Neubot.  If not, see <http://www.gnu.org/licenses/>.
#

"""
This script autogenerates <www/lang/en.js>.  Neubot does not
need such file to work because we prefer to have actual content
into Neubot HTML and JS files, so they're more readable.  But
we need to deploy en.js along with Neubot for people to able to
translate it into different languages without the burden of
starting from the italian translation.
"""

import email.utils
import glob
import os.path
import re
import xml.dom.minidom
import sys

if __name__ == "__main__":
    sys.path.insert(0, ".")

from neubot.http import ssi

def __quote(string):
    """ Prefix single quotes with backslash """
    return string.replace("'", "\\'")

def __writeone(key, value, fpout=sys.stdout, comma=","):
    """ Write one key,value pair to output file """
    key, value = __quote(key), __quote(value)

    # Keep newlines in the output document
    if not "\n" in value:
        fpout.write("    '%s': '%s'%s\n" % (key, value, comma))
    else:
        fpout.write("    '%s':\n" % key)
        lines = value.split("\n")
        fpout.write("'%s\\\n" % lines[0])
        for line in lines[1:-1]:
            fpout.write("%s\\\n" % line)
        fpout.write("%s'%s\n" % (lines[-1], comma))

    fpout.write("\n")

def _write(dictionary, fpout=sys.stdout):
    """ Write key,value pairs in dictionary to output file """
    fpout.write("// neubot/www/lang/en.js\n")
    fpout.write("\n")

    fpin = open(os.path.abspath(__file__), "r")
    _copyright = fpin.readlines()[2:21]                 # XXX fragile
    for line in _copyright:
        fpout.write(line.replace("#", "//"))

    fpout.write("\n")
    fpout.write("//\n")
    fpout.write("// WARNING! Autogenerated file: don't edit\n")
    fpout.write("// Use '%s' instead to regenerate it\n" % sys.argv[0])
    fpout.write("// Created: %s\n" % email.utils.formatdate(usegmt=True))
    fpout.write("//\n")
    fpout.write("\n")

    fpout.write("var LANG = {\n")

    keys = sorted(dictionary.keys())
    for key in keys[:-1]:
        __writeone(key, dictionary[key], fpout)

    # Last element MUST NOT end with comma
    __writeone(keys[-1], dictionary[keys[-1]], fpout, "")

    fpout.write("};\n")

def __set_dictionary(dictionary, key, value):
    """ Set key,value pair in dictionary or, if key already exists,
        make sure that the new value equals the old value """
    if key in dictionary and dictionary[key] != value:
        raise RuntimeError("Duplicate insert: %s -> %s (new: %s)" %
                (key, dictionary[key], value))
    dictionary[key] = value

def _scan_javascript(dictionary):
    """ Scan neubot javascripts for i18n.get('...') """
    for fpath in glob.glob("neubot/www/js/*.js"):
        if os.path.isfile(fpath):
            fpin = open(fpath, "r")
            match = re.findall('i18n.get\("(.*)"\)', fpin.read())
            if not match:
                continue
            for string in match:
                __set_dictionary(dictionary, string, string)

def _scan_html(dictionary, fperr=sys.stderr):
    """ Scan neubot htmls for class="i18n i18n_foo" tags """
    for html in glob.glob("neubot/www/*.html"):
        _scan_html_file(dictionary, html, fperr)
    for html in glob.glob("neubot/www/descr/*.html"):
        _scan_html_file(dictionary, html, fperr)

def _scan_html_file(dictionary, html, fperr=sys.stderr):
    ''' Scan a single html file for class="i18n i18n_foo" tags '''
    if os.path.isfile(html):
        # Skip header and footer that aren't of course well formed
        if html in ("neubot/www/header.html", "neubot/www/footer.html"):
            return

        # Open file and perform SSI substitution
        filep = open(html, "r")
        content = ssi.ssi_replace("neubot/www", filep)

        # Build DOM or fail if the file's not well formed
        fperr.write("XML: parsing %s... " % html)
        document = xml.dom.minidom.parseString(content)
        fperr.write("done\n")

        # Seek of i18n class in DOM
        __process_dom(dictionary, document.documentElement)

def __process_dom(dictionary, root, fperr=sys.stderr):
    """ Given a DOM process all the tags in the i18n class """

    # Scan all ELEMENT nodes
    for node in root.childNodes:
        if node.nodeType == node.ELEMENT_NODE:

            # Search for nodes in i18n class
            classes = node.getAttribute("class").split()
            if "i18n" in classes:

                # There MUST be just one 'i18n_' class
                subset = [elem for elem in classes
                          if elem.startswith("i18n_")]
                if len(subset) == 0:
                    raise RuntimeError("Missing i18n_foo: %s\n" % classes)
                elif len(subset) > 1:
                    raise RuntimeError("More than one i18n_foo classes")
                cls = subset[0]

                #
                # Content is not always text,
                # stringify using toxml() so we
                # keep all the tags in output
                #
                text = []
                node.normalize()
                for child in node.childNodes:
                    text.append(child.toxml())
                text = "".join(text)

                #
                # For textarea keep formatting and add \\n
                # so that javascript will properly interpret
                # it and the output is pretty.
                # Otherwise zap unneeded linear spaces.
                #
                if node.nodeName != "textarea":
                    text = re.sub("[ \t]{1,}", " ", text).strip()
                else:
                    text = text.replace("\n", "\\r\\n\n")

                __set_dictionary(dictionary, cls, text)

            else:
                __process_dom(dictionary, node, fperr)

def main():
    """ Autogenerate neubot/www/lang/en.js"""
    dictionary = {}
    fpout = open("neubot/www/lang/en.js", "w")
    _scan_javascript(dictionary)
    _scan_html(dictionary)
    _write(dictionary, fpout)
    fpout.close()

if __name__ == "__main__":
    main()
